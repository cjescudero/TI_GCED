<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aliasing – Animación interactiva</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700&family=STIX+Two+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff;
    color: #1a1a2e;
    font-family: 'STIX Two Text', 'Times New Roman', serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1.2rem 1rem;
    min-height: 100vh;
  }
  h1 {
    font-family: 'Playfair Display', serif;
    font-size: 1.7rem;
    font-weight: 700;
    margin-bottom: 0.2rem;
    text-align: center;
  }
  .top-eq {
    font-size: 1.05rem;
    color: #333;
    margin-bottom: 1rem;
    text-align: center;
  }
  canvas {
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    max-width: 100%;
  }
  .controls {
    margin-top: 1.2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.6rem;
  }
  .slider-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 1.05rem;
  }
  .slider-row label {
    font-weight: 600;
    min-width: 200px;
    text-align: right;
  }
  .slider-row input[type=range] {
    width: 340px;
    accent-color: #1b6b93;
  }
  .slider-row .val {
    min-width: 80px;
    font-style: italic;
    color: #1b6b93;
    font-size: 1.1rem;
  }
</style>
</head>
<body>

<h1>Aliasing al muestrear</h1>
<div class="top-eq">
  <i>x<sub>a</sub></i>(<i>t</i>) = <i>A</i> cos(2π<i>Ft</i> + θ) &ensp;⟺&ensp; <i>x</i>[<i>n</i>] = <i>A</i> cos(2π<i>fn</i> + θ),
  &ensp; <i>f</i> = <i>F</i>/<i>F<sub>s</sub></i>
</div>

<canvas id="c" width="900" height="530"></canvas>

<div class="controls">
  <div class="slider-row">
    <label><i>F<sub>s</sub></i> / <i>F<sub>max</sub></i> =</label>
    <input type="range" id="fsSlider" min="1.0" max="5.0" step="0.05" value="3.0"/>
    <span class="val" id="fsVal">3.00</span>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Layout
const topLabelY = 18;       // "Señal discreta" label area
const fAxisY = 130;          // f result axis (top)
const dividerY = 235;       // separator between top and bottom
const bottomLabelY = 252;   // "Muestreo" label area
const axisY = 430;           // F axis (bottom)
const centerX = W / 2;
const axisLeft = 50;
const axisRight = W - 50;
const triHeight = 120;
const Fmax_px = 80;

const fAxisLeft = centerX - 200;
const fAxisRight = centerX + 200;
const fHalfMark = 140;
const fTriHeight = 65;

let fsRatio = 3.0;

const COL_BLACK = '#1a1a2e';
const COL_BLUE = '#1b6b93';
const COL_RED = '#c0392b';
const COL_RED_LIGHT = 'rgba(192, 57, 43, 0.12)';
const COL_ORANGE = '#c78a1e';
const COL_ORANGE_LIGHT = 'rgba(199, 138, 30, 0.12)';
const COL_CYAN = '#5bafd6';
const COL_GRAY = '#888';
const COL_GREEN = '#0e7c4a';

function getFsPx() { return fsRatio * Fmax_px; }

function drawArrow(x1, y1, x2, y2, color, lw) {
  ctx.strokeStyle = color; ctx.lineWidth = lw || 1.2;
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
  const a = Math.atan2(y2 - y1, x2 - x1), s = 7;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - s * Math.cos(a - 0.4), y2 - s * Math.sin(a - 0.4));
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - s * Math.cos(a + 0.4), y2 - s * Math.sin(a + 0.4));
  ctx.stroke();
}

function drawTriangle(cx, baseY, halfW, peakH, color, alpha, dashed) {
  ctx.save(); ctx.globalAlpha = alpha;
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.setLineDash(dashed ? [7, 5] : []);
  ctx.beginPath();
  ctx.moveTo(cx - halfW, baseY); ctx.lineTo(cx, baseY - peakH); ctx.lineTo(cx + halfW, baseY);
  ctx.stroke(); ctx.setLineDash([]); ctx.restore();
}

function drawFilledTri(cx, baseY, halfW, peakH, fill, alpha) {
  ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.moveTo(cx - halfW, baseY); ctx.lineTo(cx, baseY - peakH); ctx.lineTo(cx + halfW, baseY);
  ctx.closePath(); ctx.fill(); ctx.restore();
}

// --- Section labels ---
function drawSectionLabels() {
  // Top section label
  ctx.save();
  ctx.font = '600 15px "Playfair Display", serif';
  ctx.fillStyle = '#444';
  ctx.textAlign = 'left';
  ctx.fillText('Espectro de la señal discreta resultante', 20, topLabelY + 14);

  // Divider line
  ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1;
  ctx.setLineDash([6, 4]);
  ctx.beginPath(); ctx.moveTo(20, dividerY); ctx.lineTo(W - 20, dividerY); ctx.stroke();
  ctx.setLineDash([]);

  // Bottom section label
  ctx.font = '600 15px "Playfair Display", serif';
  ctx.fillStyle = '#444';
  ctx.fillText('Efecto del muestreo: réplicas espectrales en frecuencia continua F', 20, bottomLabelY + 14);

  ctx.restore();
}

// --- Bands on F axis ---
function drawBands() {
  const Fs = getFsPx(), half = Fs / 2, bH = 18, bY = axisY - bH / 2 - 2;
  ctx.save(); ctx.globalAlpha = 0.5;

  // Main
  const mL = Math.max(centerX - half, axisLeft), mR = Math.min(centerX + half, axisRight);
  if (mR > mL) {
    ctx.fillStyle = '#f0f0f0'; ctx.strokeStyle = COL_GRAY; ctx.lineWidth = 1;
    ctx.fillRect(mL, bY, mR - mL, bH); ctx.strokeRect(mL, bY, mR - mL, bH);
  }

  // Orange left
  const oL = Math.max(centerX - half - Fs, axisLeft), oR = Math.min(centerX - half, axisRight);
  if (oR > oL) {
    ctx.fillStyle = COL_ORANGE_LIGHT; ctx.fillRect(oL, bY, oR - oL, bH);
    ctx.strokeStyle = COL_ORANGE; ctx.lineWidth = 1; ctx.strokeRect(oL, bY, oR - oL, bH);
    ctx.beginPath();
    for (let x = oL; x < oR; x += 10) { ctx.moveTo(x, bY); ctx.lineTo(Math.min(x + 12, oR), bY + bH); }
    ctx.globalAlpha = 0.2; ctx.stroke(); ctx.globalAlpha = 0.5;
  }

  // Red right
  const rL = Math.max(centerX + half, axisLeft), rR = Math.min(centerX + half + Fs, axisRight);
  if (rR > rL) {
    ctx.fillStyle = COL_RED_LIGHT; ctx.fillRect(rL, bY, rR - rL, bH);
    ctx.strokeStyle = COL_RED; ctx.lineWidth = 1; ctx.strokeRect(rL, bY, rR - rL, bH);
    ctx.beginPath();
    for (let x = rL; x < rR; x += 10) { ctx.moveTo(x, bY); ctx.lineTo(Math.min(x + 12, rR), bY + bH); }
    ctx.globalAlpha = 0.2; ctx.stroke(); ctx.globalAlpha = 0.5;
  }

  ctx.restore();
}

// --- F axis ---
function drawFAxis() {
  const Fs = getFsPx(), half = Fs / 2;
  drawArrow(axisLeft - 10, axisY, axisRight + 10, axisY, COL_BLACK, 1.2);

  ctx.strokeStyle = COL_BLACK; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(centerX, axisY - 6); ctx.lineTo(centerX, axisY + 8); ctx.stroke();

  ctx.font = '13px "STIX Two Text", serif'; ctx.fillStyle = COL_BLACK; ctx.textAlign = 'center';

  const ticks = [
    { x: centerX - half }, { x: centerX + half },
    { x: centerX - half - Fs }, { x: centerX + half + Fs },
  ];
  ctx.lineWidth = 1;
  for (const t of ticks) {
    if (t.x > axisLeft + 5 && t.x < axisRight - 5) {
      ctx.beginPath(); ctx.moveTo(t.x, axisY - 4); ctx.lineTo(t.x, axisY + 6); ctx.stroke();
    }
  }

  if (centerX - half > axisLeft + 15) ctx.fillText('−Fs/2', centerX - half, axisY + 22);
  if (centerX + half < axisRight - 15) ctx.fillText('Fs/2', centerX + half, axisY + 22);
  ctx.font = '11px "STIX Two Text", serif';
  if (centerX - half - Fs > axisLeft + 15) ctx.fillText('−(Fs/2+Fs)', centerX - half - Fs, axisY + 22);
  if (centerX + half + Fs < axisRight - 15) ctx.fillText('Fs/2+Fs', centerX + half + Fs, axisY + 22);

  ctx.font = 'italic 20px "STIX Two Text", serif'; ctx.textAlign = 'left';
  ctx.fillText('F', axisRight + 14, axisY + 7);

  ctx.font = '18px serif'; ctx.textAlign = 'center';
  ctx.fillText('⋯', axisLeft - 2, axisY + 2);
  ctx.fillText('⋯', axisRight + 4, axisY + 2);
}

// --- f axis ---
function drawFNormAxis() {
  drawArrow(fAxisLeft - 20, fAxisY, fAxisRight + 20, fAxisY, COL_BLACK, 1);

  ctx.strokeStyle = COL_BLACK; ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(centerX, fAxisY - 5); ctx.lineTo(centerX, fAxisY + 5); ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(centerX - fHalfMark, fAxisY - 4); ctx.lineTo(centerX - fHalfMark, fAxisY + 4);
  ctx.moveTo(centerX + fHalfMark, fAxisY - 4); ctx.lineTo(centerX + fHalfMark, fAxisY + 4);
  ctx.stroke();

  ctx.font = '14px "STIX Two Text", serif'; ctx.fillStyle = COL_BLACK; ctx.textAlign = 'center';
  ctx.fillText('−1/2', centerX - fHalfMark, fAxisY - 12);
  ctx.fillText('1/2', centerX + fHalfMark, fAxisY - 12);

  ctx.font = 'italic 16px "STIX Two Text", serif'; ctx.textAlign = 'left';
  ctx.fillText('f = F/Fs', fAxisRight + 24, fAxisY + 5);
}

// --- Mapping lines ---
function drawMappingLines() {
  ctx.save(); ctx.globalAlpha = 0.35;
  ctx.setLineDash([5, 4]); ctx.lineWidth = 1;
  const Fs = getFsPx(), half = Fs / 2;

  ctx.strokeStyle = COL_CYAN;
  if (centerX - half > axisLeft) {
    ctx.beginPath(); ctx.moveTo(centerX - fHalfMark, fAxisY + 8); ctx.lineTo(centerX - half, axisY - 25); ctx.stroke();
  }
  if (centerX + half < axisRight) {
    ctx.beginPath(); ctx.moveTo(centerX + fHalfMark, fAxisY + 8); ctx.lineTo(centerX + half, axisY - 25); ctx.stroke();
  }

  ctx.strokeStyle = COL_RED;
  if (centerX + half < axisRight) {
    ctx.beginPath(); ctx.moveTo(centerX - fHalfMark, fAxisY + 8); ctx.lineTo(centerX + half, axisY - 25); ctx.stroke();
  }
  if (centerX + half + Fs < axisRight) {
    ctx.beginPath(); ctx.moveTo(centerX + fHalfMark, fAxisY + 8); ctx.lineTo(centerX + half + Fs, axisY - 25); ctx.stroke();
  }

  ctx.strokeStyle = COL_ORANGE;
  if (centerX - half > axisLeft) {
    ctx.beginPath(); ctx.moveTo(centerX + fHalfMark, fAxisY + 8); ctx.lineTo(centerX - half, axisY - 25); ctx.stroke();
  }
  if (centerX - half - Fs > axisLeft) {
    ctx.beginPath(); ctx.moveTo(centerX - fHalfMark, fAxisY + 8); ctx.lineTo(centerX - half - Fs, axisY - 25); ctx.stroke();
  }

  ctx.setLineDash([]); ctx.restore();
}

// --- Spectra on F axis ---
function drawOrigSpectrum() {
  drawFilledTri(centerX, axisY - 20, Fmax_px, triHeight, 'rgba(27,107,147,0.08)', 1);
  drawTriangle(centerX, axisY - 20, Fmax_px, triHeight, COL_BLUE, 1, false);
}

function drawReplica(offset, color, fill, alpha) {
  const cx = centerX + offset * getFsPx();
  if (cx - Fmax_px > axisRight + 20 || cx + Fmax_px < axisLeft - 20) return;
  drawFilledTri(cx, axisY - 20, Fmax_px, triHeight, fill, alpha * 0.5);
  drawTriangle(cx, axisY - 20, Fmax_px, triHeight, color, alpha, true);
}

// --- Result spectrum on f axis ---
function drawResultSpectrum() {
  ctx.save();
  const Fs = getFsPx(), half = Fs / 2;
  const hasAliasing = Fmax_px > half;
  const fmax_f = Math.min(Fmax_px / half, 1.0);
  const fmax_px = fmax_f * fHalfMark;

  if (!hasAliasing) {
    drawFilledTri(centerX, fAxisY, fmax_px, fTriHeight, 'rgba(14, 124, 74, 0.1)', 1);
    drawTriangle(centerX, fAxisY, fmax_px, fTriHeight, COL_GREEN, 1, false);

    ctx.font = '14px "STIX Two Text", serif'; ctx.fillStyle = COL_GREEN; ctx.textAlign = 'center';
    ctx.fillText('✓ Sin aliasing (Fs > 2Fmax)', centerX, fAxisY - fTriHeight - 8);
  } else {
    ctx.beginPath();
    ctx.rect(centerX - fHalfMark - 2, fAxisY - fTriHeight - 30, fHalfMark * 2 + 4, fTriHeight + 32);
    ctx.clip();

    drawFilledTri(centerX, fAxisY, fmax_px, fTriHeight, 'rgba(27,107,147,0.06)', 0.8);
    drawTriangle(centerX, fAxisY, fmax_px, fTriHeight, COL_BLUE, 0.5, false);

    const repR = centerX + fHalfMark * 2;
    drawFilledTri(repR, fAxisY, fmax_px, fTriHeight, 'rgba(192,57,43,0.08)', 0.6);
    drawTriangle(repR, fAxisY, fmax_px, fTriHeight, COL_RED, 0.6, true);

    const repL = centerX - fHalfMark * 2;
    drawFilledTri(repL, fAxisY, fmax_px, fTriHeight, 'rgba(199,138,30,0.08)', 0.6);
    drawTriangle(repL, fAxisY, fmax_px, fTriHeight, COL_ORANGE, 0.6, true);

    ctx.restore();
    ctx.save();

    const overlapStart_px = fHalfMark * 2 - fmax_px;
    if (overlapStart_px < fHalfMark) {
      ctx.fillStyle = 'rgba(200, 0, 0, 0.12)';
      ctx.fillRect(centerX + overlapStart_px, fAxisY - fTriHeight, fHalfMark - overlapStart_px, fTriHeight);
      ctx.fillRect(centerX - fHalfMark, fAxisY - fTriHeight, fHalfMark - overlapStart_px, fTriHeight);
    }

    ctx.font = 'bold 14px "STIX Two Text", serif'; ctx.fillStyle = COL_RED; ctx.textAlign = 'center';
    ctx.fillText('¡ALIASING! (Fs < 2Fmax)', centerX, fAxisY - fTriHeight - 8);
  }

  ctx.restore();
}

// --- Overlap warning on F axis ---
function drawOverlapWarning() {
  const Fs = getFsPx(), half = Fs / 2;
  if (Fmax_px > half) {
    const ov = Fmax_px - half;
    ctx.save(); ctx.globalAlpha = 0.2; ctx.fillStyle = '#ff0000';
    ctx.fillRect(centerX - half - ov, axisY - 20 - triHeight, ov * 2, triHeight);
    ctx.fillRect(centerX + half - ov, axisY - 20 - triHeight, ov * 2, triHeight);
    ctx.restore();

    ctx.save();
    ctx.font = '13px "STIX Two Text", serif'; ctx.fillStyle = COL_RED; ctx.textAlign = 'center';
    ctx.fillText('Solapamiento entre réplicas', centerX, axisY + 40);
    ctx.restore();
  } else {
    ctx.save();
    ctx.font = '13px "STIX Two Text", serif'; ctx.fillStyle = COL_GREEN; ctx.textAlign = 'center';
    ctx.fillText('Fs > 2Fmax → Sin solapamiento entre réplicas', centerX, axisY + 40);
    ctx.restore();
  }
}

// --- Main draw ---
function draw() {
  ctx.clearRect(0, 0, W, H);
  drawSectionLabels();

  // Top: result
  drawFNormAxis();
  drawResultSpectrum();

  // Bottom: sampling effect
  drawFAxis();
  drawBands();
  drawMappingLines();
  drawOrigSpectrum();
  drawReplica(1, COL_RED, COL_RED_LIGHT, 0.8);
  drawReplica(-1, COL_ORANGE, COL_ORANGE_LIGHT, 0.8);
  drawReplica(2, COL_RED, COL_RED_LIGHT, 0.35);
  drawReplica(-2, COL_ORANGE, COL_ORANGE_LIGHT, 0.35);
  drawOverlapWarning();
}

// --- Slider ---
const slider = document.getElementById('fsSlider');
const fsValLabel = document.getElementById('fsVal');

slider.addEventListener('input', () => {
  fsRatio = parseFloat(slider.value);
  fsValLabel.textContent = fsRatio.toFixed(2);
  draw();
});

// Initial draw
draw();
</script>

</body>
</html>
